%% Syntax
tp: type.
arr: tp -> tp -> tp.
all: (tp -> tp) -> tp.

tm: type.
app: tm -> tm -> tm.
lam: (tm -> tm) -> tm.
tapp: tm -> tp -> tm.
tlam: (tp -> tm) -> tm.

%% Judgments
atp: tp -> tp -> type.  
aeq: tm -> tm -> type.

%% Rules
at_al : ({a:tp} atp a a -> atp (T a) (S a))
	-> atp (all T) (all S).
at_arr: atp T1 T2 -> atp S1 S2
	-> atp (arr T1 S1) (arr T2 S2).
ae_l: ({x:tm} aeq x x -> aeq (M x) (N x)) 
        -> aeq (lam (\x. M x)) (lam (\x. N x)).
ae_a: aeq M1 N1 -> aeq M2 N2 -> aeq (app M1 M2) (app N1 N2).
ae_tl: ({a:tp} atp a a -> aeq (M a) (N a)) 
        -> aeq (tlam (\a. M a)) (tlam (\a. N a)).
ae_ta: aeq M N -> atp T S -> aeq (tapp M T) (tapp N S).

%% Schemas
schema aG =  block (a:tp);
schema axG = block (a:tp) + block (x:tm);
schema atpG  = block a:tp , _t:atp a a;
%% schema aeqG: block (a:tp, u:atp a a) + block (x:tm, v:aeq x x);
schema aeqG  = block (x:tm, _u:aeq x x) + block (a:tp , _t:atp a a);

%% Definitions
inductive Ratp: {g:aG} {h:atpG} prop =
| Atp_nil: Ratp [] []
| Atp_cons : Ratp [g] [h] -> Ratp [g, b: block a:tp] [h, b:block a:tp, u:atp a a];

inductive Raeq: {g:axG} {h:aeqG} prop =
| Aeq_nil: Raeq [] []
| Aeq_cons1 : Raeq [g] [h] -> Raeq [g, b: block a:tp] [h, b: block a:tp, u:atp a a]
| Aeq_cons2 : Raeq [g] [h] -> Raeq [g, b: block x:tm] [h, b:block x:tm, u:aeq x x]
;

{%
%% Theorems
theorem reflTpG: {h:atpG} {A:tp} [h |- atp A A].
theorem reflTmG: {h:aeqG} {M:tm} [h |- aeq M M].

theorem reflTpR: {g:aG} {h:atpG} {A:tp} Ratp g h -> [h |- atp A A].
theorem reflTmR: {g:axG} {h:aeqG} {M:tm} Raeq g h -> [h |- aeq M M].
%}

%% Directives
% [hy,ab] wf tp.
% [hy,ab] wf tm.
% [hy,ab] explicit a in aG.
% [hy,ab] explicit a in axG.
% [hy,ab] explicit x in axG.
% [hy,ab] explicit a in atpG.
% [hy,ab] explicit a in aeqG.
% [hy,ab] explicit x in aeqG.
% [hy,ab] explicit a in g in Ratp.
% [hy,ab] explicit a in g in Raeq.
% [hy,ab] explicit x in g in Raeq.
