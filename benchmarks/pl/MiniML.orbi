% MiniML
% Author: Brigitte Pientka, following FP
% ported to ORBI by AM, merging with Abella's pcf, adding fix and closed

%% Syntax

tp   : type.
nat  : tp.
arrow  : tp -> tp -> tp.

exp  : type.
z    : exp.
suc  : exp -> exp.
match: exp -> exp -> (exp -> exp) -> exp.
letv : exp -> (exp -> exp) -> exp.  % let x = e1 in e2
lam  : (exp -> exp) -> exp.
fix  : (exp -> exp) -> exp.
app  : exp -> exp -> exp.


%% Judgments

% Equalities
eeq : exp -> exp -> type.
teq : tp -> tp -> type.
% Evaluation
eval : exp -> exp -> type.
% Typing
oft : exp -> tp -> type.

% Value
value : exp -> type.
% Progress
progress : exp -> type.


% Reduction
red1 : exp -> exp -> type.
reds : exp -> exp -> type.

% Closed
closed : exp -> type.


%% Rules
ev_z : eval z z.
ev_s : eval E V -> eval (suc E) (suc V).
ev_m_z: eval (match E E1 (\x. E2 x)) V
	<- eval E z
	<- eval E1 V.
ev_m_s: eval (match E E1 (\x. E2 x)) V
	<- eval E (suc V2)
	<- eval (E2 V2) V.
ev_l : eval (E2 V1) V  -> eval E1 V1 -> eval (letv E1 (\x. E2 x)) V.
ev_lam: eval (lam  (\x. E x)) (lam  (\x. E x)).
ev_app: eval E1 (lam  (\x. E x)) -> eval E2 V2 -> eval (E V2) V
     -> eval (app E1 E2) V.
ev_fix  : eval (fix (\x. E x)) V
	   <- eval (E (fix E)) V.

val_z     : value z.
val_lam   : value (lam E).
val_s     : value (suc V)
	     <- value V.

red_z    : red1 (match z E1 E2) E1.
red_s    : red1 (match (suc E) E1 E2)  (E2 E).
red_app  : red1 (app (lam E1) E2)   (E1 E2).
red_letv : red1 (letv E1 E2) (E2 E1).
red_fix  : red1 (fix E)  (E (fix E)).


red*_s : reds (suc E)  (suc E')
	  <- reds E E'.
red*_match : reds (match E1 E2 E3)  (match E1' E2 E3)
	     <- reds E1 E1'.
red*_app1 : reds (app E1 E2) (app E1' E2)
	     <- reds E1  E1'.
red*_app2 : reds (app E1 E2)  (app E1 E2')
	     <- reds E2 E2'.
red*_letv : reds (letv E1 E2) (letv E1' E2)
	     <- reds E1 E1'.

red*_beta : reds E  E'
	     <- red1 E E'.
red*_refl : reds E E.
red*_trans : reds E E''
	      <- reds E E'
	      <- reds E' E''.

prog_v : value E -> progress E.
prog_s : red1 E E' -> progress E.

tp_z     : oft z nat.
tp_s     : oft E nat ->
	   oft (suc E) nat.
tp_match : oft (match E E1 (\x. E2 x)) T
	 <- oft E nat
	 <- oft E1 T
	 <- ({x:exp} oft x nat -> oft (E2 x) T).
tp_lam :   ({x:exp} oft x T1 -> oft (E x) T2)
        -> oft (lam  (\x . E x)) (arrow T1 T2).
tp_app : oft E2 T2 ->
         oft E1 (arrow T2 T1)
	 -> oft (app E1 E2) T1.
tp_letv : ({x:exp} oft x T1 -> oft (E2 x) T2) ->
	   oft E1 T1
        -> oft (letv E1 (\ x . E2 x)) T2.
tp_fix : oft (fix E) T
	  <- ({x:exp} oft x T -> oft (E x) T).

t_refl : teq T T.
e_refl : eeq E E.


clo_z     : closed z.
clo_s     : closed (suc E)
	     <- closed E.
clo_match  : closed (match E1 E2 E3)
	     <- closed E1
	     <- closed E2
	     <- ({x:exp} closed x -> closed (E3 x)).
clo_lam : closed (lam E)
	     <- ({x:exp} closed x -> closed (E x)).
clo_app : closed (app E1 E2)
	     <- closed E1
	     <- closed E2.
clo_letv : closed (letv E1 E2)
	      <- closed E1
	      <- ({x:exp} closed x -> closed (E2 x)).
clo_fix : closed (fix E)
	     <- ({x:exp} closed x -> closed (E x)).


%% Schemas
schema oG = some [t:tp] block (x:exp, d:oft x t);
schema cloG = block (x:exp, d: closed x);


%% Definitions

% Type block (x:exp, u:oft x (T ..)) doesn't check against schema .
inductive Goft: {g:oG} prop =
| Oft_nil: Goft []
| Oft_cons: Goft []  -> Goft [g, b: block x:exp, u:oft x T[]];

rec vs: [ |- eval E V] -> [ |- value V] = ? ;
rec evu:    [ |- eval E V1] -> [|- eval E V2] -> [ |- eeq V1 V2] = ? ;
rec tps:  [ |- eval E V] -> [ |- oft E T] -> [ |- oft V T] = ? ;
rec tu:   {h:oG}[h |- oft E T1[]] -> [h |- oft E T2[]] -> [ |- teq T1 T2] = ? ;

rec prog: [ |- oft E T] -> [ |- progress E] = ? ;
rec tpsr:  [ |- red1 E E'] -> [ |- oft E T] -> [ |- oft E' T] = ? ;
rec ts:   [ |- reds E V] ->  [ |- oft E T] ->   [ |- oft V T] = ? ;
rec ru:    [ |- red1 E E1] -> [ |- red1 E E2] -> [ |- eeq E1 E2] = ? ;

rec evalRed: [ |- eval E V] -> [ |- reds E V] = ? ;

rec eval_value:   [ |- value V] -> [ |- eval V V] = ? ;
   rec red1_eval :  [ |- red1 E E'] -> [ |- eval E' V] -> [ |- eval E V] = ? ;
      rec red_eval:  [ |- reds E V] -> [ |- value V] -> [ |- eval E V] = ? ;

%{
%% Theorems

theorem vs: {E:exp} {V:exp}[ |- eval E V] -> [ |- value V].
theorem evu:  {E:exp} {V1:exp} {V2:exp}  [ |- eval E V1] -> [|- eval E V2] -> [ |- eeq V1 V2].
theorem tps:  {E:exp} {V:exp} {T:tp}[ |- eval E V] -> [ |- oft E T] -> [ |- oft V T].
theorem tu:    {h:Goft} {E:exp} {T1:tp} {T2:tp}[h |- oft E T1] -> [h |- oft E T2] -> [ |- teq T1 T2].

theorem prog: {E:exp} {T:tp}[ |- oft E T] -> [ |- progress E].
theorem tpsr:  {E:exp} {E':exp} {T:tp} [ |- red1 E E'] -> [ |- oft E T] -> [ |- oft E' T].
theorem ts:   {E:exp} {V:exp} {T:tp}[ |- reds E V] ->  [ |- oft E T] ->   [ |- oft V T].
theorem ru:   {E:exp} {E1:exp} {E2:exp} [ |- red1 E E1] -> [ |- red1 E E2] -> [ |- eeq E1 E2].

theorem evalRed:  {E:exp} {V:exp}[ |- eval E V] -> [ |- reds E V].

% indentatation to suggest dependencies
theorem eval_value:   {V:exp}[ |- value V] -> [ |- eval V V].
   theorem red1_eval :  {E:exp} {E':exp} {V_exp} [ |- red1 E E'] -> [ |- eval E' V] -> [ |- eval E V].
      theorem red_eval: {E:exp} {V:exp} [ |- reds E V] -> [ |- value V] -> [ |- eval E V].
%}
